using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace DigitalRightsManagement.SourceGenerators;

/// <summary>
/// A source generator that generates constructors for classes inheriting from the Entity base class.
/// </summary>
[Generator]
public class EntityConstructorGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator and registers the syntax provider.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(
            classDeclarations,
            static (spc, source) => Execute(source!, spc));
    }

    /// <summary>
    /// Determines if the given syntax node is a target for generation.
    /// </summary>
    /// <param name="node">The syntax node.</param>
    /// <returns>True if the node is a class declaration with a base type; otherwise, false.</returns>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDeclaration)
        {
            return false;
        }

        return classDeclaration.BaseList?.Types.Count > 0;
    }

    /// <summary>
    /// Gets the semantic target for generation.
    /// </summary>
    /// <param name="context">The generator syntax context.</param>
    /// <returns>The class declaration syntax if the class inherits from the Entity base class; otherwise, null.</returns>
    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == "Entity" && baseType.ContainingNamespace.ToDisplayString() == "DigitalRightsManagement.Common.DDD")
            {
                return classDeclaration;
            }
            baseType = baseType.BaseType;
        }

        return null;
    }

    /// <summary>
    /// Executes the source generation for the given class declaration.
    /// </summary>
    /// <param name="classDeclaration">The class declaration syntax.</param>
    /// <param name="context">The source production context.</param>
    private static void Execute(ClassDeclarationSyntax classDeclaration, SourceProductionContext context)
    {
        var namespaceName = GetNamespace(classDeclaration);
        var className = classDeclaration.Identifier.Text;
        var isSealed = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.SealedKeyword));
        var generics = classDeclaration.TypeParameterList?.Parameters;

        var genericTypes = generics != null ? $"<{string.Join(", ", generics)}>" : string.Empty;

        var accessibility = isSealed ? "private" : "protected";

        var source = $$"""
                       // <auto-generated/>
                       #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member 'AggregateRoot.AggregateRoot()'
                       #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
                       namespace {{namespaceName}}
                       {
                           partial class {{className}}{{genericTypes}}
                           {
                               {{accessibility}} {{className}}() { }
                           }
                       }
                       """;

        context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    /// <summary>
    /// Gets the namespace for the given class declaration.
    /// </summary>
    /// <param name="classDeclaration">The class declaration syntax.</param>
    /// <returns>The namespace as a string.</returns>
    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceName = string.Empty;
        var potentialNamespaceParent = classDeclaration.Parent;

        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax &&
               potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            namespaceName = namespaceParent.Name.ToString();
            while (namespaceParent.Parent is NamespaceDeclarationSyntax parent)
            {
                namespaceName = $"{parent.Name}.{namespaceName}";
                namespaceParent = parent;
            }
        }

        return namespaceName;
    }
}
