using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace DigitalRightsManagement.SourceGenerators;

[Generator]
public class EntityConstructorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(
            classDeclarations,
            static (spc, source) => Execute(source!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDeclaration)
        {
            return false;
        }

        return classDeclaration.BaseList?.Types.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        var baseType = symbol.BaseType;
        while (baseType != null)
        {
            if (baseType.Name == "Entity" && baseType.ContainingNamespace.ToDisplayString() == "DigitalRightsManagement.Common.DDD")
            {
                return classDeclaration;
            }
            baseType = baseType.BaseType;
        }

        return null;
    }

    private static void Execute(ClassDeclarationSyntax classDeclaration, SourceProductionContext context)
    {
        var namespaceName = GetNamespace(classDeclaration);
        var className = classDeclaration.Identifier.Text;
        var isSealed = classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.SealedKeyword));

        var accessibility = isSealed ? "private" : "protected";

        var source = $$"""
                       // <auto-generated/>
                       #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member 'AggregateRoot.AggregateRoot()'
                       #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
                       namespace {{namespaceName}}
                       {
                           partial class {{className}}
                           {
                               {{accessibility}} {{className}}() { }
                           }
                       }
                       """;

        context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GetNamespace(ClassDeclarationSyntax classDeclaration)
    {
        var namespaceName = string.Empty;
        var potentialNamespaceParent = classDeclaration.Parent;

        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax &&
               potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            namespaceName = namespaceParent.Name.ToString();
            while (namespaceParent.Parent is NamespaceDeclarationSyntax parent)
            {
                namespaceName = $"{parent.Name}.{namespaceName}";
                namespaceParent = parent;
            }
        }

        return namespaceName;
    }
}